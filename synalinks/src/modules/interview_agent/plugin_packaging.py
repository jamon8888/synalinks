"""
Plugin Packaging System for Interview Agent

Automatically generates Claude Code plugins based on user requirements
discovered during interviews and packages them for easy installation.
"""

import os
import json
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime

from synalinks.src.modules.interview_agent import (
    Requirement,
    PRD,
    Plugin,
    User,
)


# ============================================================================
# PLUGIN TEMPLATES
# ============================================================================


class PluginTemplate:
    """Base class for plugin templates."""

    def __init__(self, plugin_config: Dict):
        self.config = plugin_config
        self.name = plugin_config["name"]
        self.description = plugin_config["description"]
        self.category = plugin_config.get("category", "general")

    def generate_manifest(self) -> Dict:
        """Generate plugin.json manifest."""
        return {
            "name": self.name,
            "displayName": self.config.get("displayName", self.name.replace("-", " ").title()),
            "description": self.description,
            "version": self.config.get("version", "1.0.0"),
            "author": {
                "name": self.config.get("author", "Interview Agent"),
                "url": self.config.get("author_url", ""),
            },
            "keywords": self.config.get("keywords", [self.category]),
            "license": self.config.get("license", "MIT"),
            "engines": {
                "claude-code": ">=1.0.0"
            }
        }

    def generate_readme(self) -> str:
        """Generate README.md."""
        return f"""# {self.name}

{self.description}

## Installation

```bash
/plugin marketplace add interview-plugins/recommended
/plugin install {self.name}@interview-plugins
```

## Generated by Interview Agent

This plugin was automatically generated based on your interview responses.

**Category**: {self.category}

## Usage

[Plugin-specific usage instructions]

## Requirements

- Claude Code >= 1.0.0

## License

{self.config.get('license', 'MIT')}
"""

    def generate_claude_md(self) -> str:
        """Generate CLAUDE.md for context."""
        return f"""# {self.name} Plugin

## Purpose
{self.description}

## Generated From Interview
This plugin was created based on user needs discovered during an AI interview:
- **Category**: {self.category}
- **Generated**: {datetime.now().isoformat()}

## How This Plugin Helps
[Specific benefits based on user requirements]

## Integration
This plugin is part of a personalized plugin bundle recommended by the Interview Agent.
"""


class CommandPlugin(PluginTemplate):
    """Plugin with slash commands."""

    def generate_command(self, command_name: str, command_config: Dict) -> str:
        """Generate a slash command markdown file."""
        return f"""---
description: {command_config.get('description', 'Command description')}
---

# {command_name}

{command_config.get('prompt', 'Execute the command')}

## Usage

```
/{command_name} [arguments]
```

## Examples

{command_config.get('examples', '- Example usage here')}
"""


class MCPPlugin(PluginTemplate):
    """Plugin with MCP server integration."""

    def generate_mcp_config(self, server_config: Dict) -> Dict:
        """Generate .mcp.json configuration."""
        return {
            "servers": {
                self.config.get("server_name", f"{self.name}-server"): {
                    "command": server_config.get("command", "node"),
                    "args": server_config.get("args", ["${CLAUDE_PLUGIN_ROOT}/server.js"]),
                    "transport": server_config.get("transport", "stdio"),
                    "env": server_config.get("env", {})
                }
            }
        }


class SkillPlugin(PluginTemplate):
    """Plugin with reusable skills."""

    def generate_skill(self, skill_name: str, skill_config: Dict) -> str:
        """Generate SKILL.md for a skill."""
        return f"""---
name: {skill_name}
description: {skill_config.get('description', 'Skill description')}
---

# {skill_name} Skill

## Capability
{skill_config.get('capability', 'What this skill does')}

## When to Use
{skill_config.get('when_to_use', 'Situations where this skill is helpful')}

## Examples
{skill_config.get('examples', '- Example usage')}
"""


# ============================================================================
# PLUGIN GENERATOR
# ============================================================================


class PluginGenerator:
    """
    Generates Claude Code plugins from interview requirements.

    Converts discovered user needs into installable plugin packages.
    """

    def __init__(self, output_dir: str = "./generated_plugins"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

    def generate_plugin_from_requirement(
        self,
        requirement: Requirement,
        user: User,
        additional_config: Optional[Dict] = None
    ) -> Path:
        """
        Generate a plugin from a single requirement.

        Args:
            requirement: User requirement from interview
            user: User who provided the requirement
            additional_config: Extra configuration options

        Returns:
            Path to generated plugin directory
        """
        # Create plugin name from requirement
        plugin_name = self._create_plugin_name(requirement)
        plugin_dir = self.output_dir / plugin_name

        # Determine plugin type based on requirement category
        plugin_type = self._determine_plugin_type(requirement)

        # Create plugin structure
        self._create_plugin_structure(plugin_dir)

        # Generate plugin configuration
        config = self._create_plugin_config(requirement, user, additional_config)

        # Generate based on type
        if plugin_type == "command":
            template = CommandPlugin(config)
            self._generate_command_plugin(plugin_dir, template, requirement)
        elif plugin_type == "mcp":
            template = MCPPlugin(config)
            self._generate_mcp_plugin(plugin_dir, template, requirement)
        elif plugin_type == "skill":
            template = SkillPlugin(config)
            self._generate_skill_plugin(plugin_dir, template, requirement)
        else:
            template = PluginTemplate(config)
            self._generate_basic_plugin(plugin_dir, template)

        # Write common files
        self._write_manifest(plugin_dir, template)
        self._write_readme(plugin_dir, template)
        self._write_claude_md(plugin_dir, template)

        print(f"✓ Generated plugin: {plugin_name} at {plugin_dir}")
        return plugin_dir

    def generate_bundle_from_prd(
        self,
        prd: PRD,
        bundle_name: str = "interview-recommended-bundle"
    ) -> Path:
        """
        Generate a complete plugin bundle from PRD.

        Creates multiple plugins based on all requirements.

        Args:
            prd: Product Requirements Document from interview
            bundle_name: Name for the plugin bundle

        Returns:
            Path to bundle directory
        """
        bundle_dir = self.output_dir / bundle_name
        bundle_dir.mkdir(exist_ok=True)

        print(f"\nGenerating plugin bundle: {bundle_name}")
        print(f"Requirements to process: {len(prd.requirements.all_requirements)}")

        generated_plugins = []

        # Generate plugin for each high-priority requirement
        for req in prd.requirements.all_requirements:
            if req.priority >= 4:  # Only high priority
                try:
                    plugin_path = self.generate_plugin_from_requirement(
                        requirement=req,
                        user=prd.user,
                    )
                    generated_plugins.append(plugin_path.name)
                except Exception as e:
                    print(f"  ⚠ Error generating plugin for {req.name}: {e}")

        # Create marketplace.json for the bundle
        self._create_marketplace_json(bundle_dir, generated_plugins, prd)

        # Create bundle README
        self._create_bundle_readme(bundle_dir, prd, generated_plugins)

        print(f"\n✓ Bundle generated with {len(generated_plugins)} plugins")
        return bundle_dir

    # ------------------------------------------------------------------------
    # PRIVATE HELPER METHODS
    # ------------------------------------------------------------------------

    def _create_plugin_name(self, requirement: Requirement) -> str:
        """Create kebab-case plugin name from requirement."""
        name = requirement.name.lower()
        name = name.replace(" ", "-")
        name = "".join(c for c in name if c.isalnum() or c == "-")
        return name

    def _determine_plugin_type(self, requirement: Requirement) -> str:
        """Determine plugin type from requirement category."""
        category_to_type = {
            "automation": "command",
            "coding": "skill",
            "testing": "command",
            "documentation": "command",
            "data_analysis": "mcp",
            "integration": "mcp",
        }
        return category_to_type.get(requirement.category, "basic")

    def _create_plugin_structure(self, plugin_dir: Path):
        """Create standard plugin directory structure."""
        plugin_dir.mkdir(parents=True, exist_ok=True)
        (plugin_dir / ".claude-plugin").mkdir(exist_ok=True)

    def _create_plugin_config(
        self,
        requirement: Requirement,
        user: User,
        additional_config: Optional[Dict]
    ) -> Dict:
        """Create plugin configuration dictionary."""
        config = {
            "name": self._create_plugin_name(requirement),
            "description": requirement.description,
            "category": requirement.category,
            "version": "1.0.0",
            "priority": requirement.priority,
            "author": user.name,
            "generated_from": "interview_agent",
            "keywords": [requirement.category, "interview-recommended"],
        }

        if additional_config:
            config.update(additional_config)

        return config

    def _generate_command_plugin(
        self,
        plugin_dir: Path,
        template: CommandPlugin,
        requirement: Requirement
    ):
        """Generate a command-based plugin."""
        commands_dir = plugin_dir / "commands"
        commands_dir.mkdir(exist_ok=True)

        # Generate main command
        command_name = template.name.replace("-", "_")
        command_config = {
            "description": requirement.description,
            "prompt": f"Help the user with: {requirement.description}",
            "examples": f"- /{command_name}\n- /{command_name} --help"
        }

        command_content = template.generate_command(command_name, command_config)
        (commands_dir / f"{command_name}.md").write_text(command_content)

    def _generate_mcp_plugin(
        self,
        plugin_dir: Path,
        template: MCPPlugin,
        requirement: Requirement
    ):
        """Generate an MCP server plugin."""
        # Generate .mcp.json
        server_config = {
            "command": "node",
            "args": ["${CLAUDE_PLUGIN_ROOT}/server.js"],
            "transport": "stdio"
        }

        mcp_config = template.generate_mcp_config(server_config)
        (plugin_dir / ".mcp.json").write_text(
            json.dumps(mcp_config, indent=2)
        )

        # Create placeholder server
        server_template = """// MCP Server for {name}
// Generated by Interview Agent

const Server = require('@modelcontextprotocol/sdk/server');
const StdioServerTransport = require('@modelcontextprotocol/sdk/server/stdio');

const server = new Server({{
  name: '{name}',
  version: '1.0.0'
}});

// Add your MCP server implementation here

const transport = new StdioServerTransport();
server.connect(transport);
"""
        (plugin_dir / "server.js").write_text(
            server_template.format(name=template.name)
        )

    def _generate_skill_plugin(
        self,
        plugin_dir: Path,
        template: SkillPlugin,
        requirement: Requirement
    ):
        """Generate a skill-based plugin."""
        skills_dir = plugin_dir / "skills" / template.name
        skills_dir.mkdir(parents=True, exist_ok=True)

        skill_config = {
            "description": requirement.description,
            "capability": f"Provides {requirement.name} functionality",
            "when_to_use": f"When the user needs help with {requirement.category}",
            "examples": f"- Use this skill for {requirement.name}"
        }

        skill_content = template.generate_skill(template.name, skill_config)
        (skills_dir / "SKILL.md").write_text(skill_content)

    def _generate_basic_plugin(self, plugin_dir: Path, template: PluginTemplate):
        """Generate a basic plugin with just manifest and docs."""
        # Basic plugins just have manifest + README
        pass

    def _write_manifest(self, plugin_dir: Path, template: PluginTemplate):
        """Write plugin.json manifest."""
        manifest = template.generate_manifest()
        manifest_path = plugin_dir / ".claude-plugin" / "plugin.json"
        manifest_path.write_text(json.dumps(manifest, indent=2))

    def _write_readme(self, plugin_dir: Path, template: PluginTemplate):
        """Write README.md."""
        readme = template.generate_readme()
        (plugin_dir / "README.md").write_text(readme)

    def _write_claude_md(self, plugin_dir: Path, template: PluginTemplate):
        """Write CLAUDE.md."""
        claude_md = template.generate_claude_md()
        (plugin_dir / "CLAUDE.md").write_text(claude_md)

    def _create_marketplace_json(
        self,
        bundle_dir: Path,
        plugin_names: List[str],
        prd: PRD
    ):
        """Create marketplace.json for plugin discovery."""
        marketplace = {
            "name": "Interview Recommended Plugins",
            "description": f"Personalized plugins for {prd.user.name} based on interview discovery",
            "author": {
                "name": "Interview Agent",
            },
            "plugins": []
        }

        # Add each plugin
        for plugin_name in plugin_names:
            plugin_dir = self.output_dir / plugin_name
            manifest_path = plugin_dir / ".claude-plugin" / "plugin.json"

            if manifest_path.exists():
                manifest = json.loads(manifest_path.read_text())
                marketplace["plugins"].append({
                    "name": plugin_name,
                    "displayName": manifest.get("displayName", plugin_name),
                    "description": manifest.get("description", ""),
                    "version": manifest.get("version", "1.0.0"),
                    "keywords": manifest.get("keywords", []),
                    "source": f"./{plugin_name}"
                })

        marketplace_path = bundle_dir / ".claude-plugin" / "marketplace.json"
        marketplace_path.parent.mkdir(exist_ok=True)
        marketplace_path.write_text(json.dumps(marketplace, indent=2))

    def _create_bundle_readme(
        self,
        bundle_dir: Path,
        prd: PRD,
        plugin_names: List[str]
    ):
        """Create README for the bundle."""
        readme = f"""# Interview Recommended Plugin Bundle

Personalized plugin collection for **{prd.user.name}** ({prd.user.role})

Generated: {datetime.now().strftime('%Y-%m-%d')}

## About This Bundle

This plugin bundle was automatically generated based on an AI-powered interview that discovered your specific needs and workflows.

**Your Profile:**
- Role: {prd.user.role}
- Experience: {prd.user.experience_level}
- Industry: {prd.user.industry or 'General'}

## Plugins Included ({len(plugin_names)})

{chr(10).join(f'- **{name}**' for name in plugin_names)}

## Installation

### Quick Install (Recommended)

```bash
# Add this marketplace
/plugin marketplace add [your-repo-url]

# Install all plugins
{chr(10).join(f'/plugin install {name}@interview-plugins' for name in plugin_names)}
```

### Alternative: NPM CLI

```bash
npx claude-plugins install @yourorg/interview-plugins/{plugin_names[0] if plugin_names else 'plugin-name'}
```

## Requirements Addressed

This bundle addresses {len(prd.requirements.all_requirements)} requirements across {len(prd.requirements.by_category)} categories:

{chr(10).join(f'- **{cat}**: {len(reqs)} requirements' for cat, reqs in prd.requirements.by_category.items())}

## Next Steps

1. Install the plugins using commands above
2. Review individual plugin READMEs for usage
3. Customize configurations as needed
4. Provide feedback to improve recommendations

## Generated by Interview Agent

Powered by Synalinks Interview Agent - AI-driven discovery and plugin recommendation system.
"""
        (bundle_dir / "README.md").write_text(readme)


# ============================================================================
# MARKETPLACE BUILDER
# ============================================================================


class MarketplaceBuilder:
    """
    Builds and manages Claude Code plugin marketplaces.

    Creates GitHub-ready repositories with marketplace.json.
    """

    def __init__(self, marketplace_dir: str = "./plugin-marketplace"):
        self.marketplace_dir = Path(marketplace_dir)

    def create_marketplace_repo(
        self,
        marketplace_name: str,
        plugins_dir: Path,
        prd: PRD
    ) -> Path:
        """
        Create a complete marketplace repository.

        Args:
            marketplace_name: Name of the marketplace
            plugins_dir: Directory containing generated plugins
            prd: PRD with user information

        Returns:
            Path to marketplace repo
        """
        repo_dir = self.marketplace_dir / marketplace_name
        repo_dir.mkdir(parents=True, exist_ok=True)

        print(f"\nCreating marketplace repository: {marketplace_name}")

        # Copy plugins
        self._copy_plugins(plugins_dir, repo_dir)

        # Create marketplace.json
        self._create_root_marketplace_json(repo_dir, prd)

        # Create repository README
        self._create_repo_readme(repo_dir, prd)

        # Create CLAUDE.md for context
        self._create_repo_claude_md(repo_dir, prd)

        # Create installation guide
        self._create_install_guide(repo_dir, marketplace_name)

        # Create GitHub Actions (optional)
        # self._create_github_actions(repo_dir)

        print(f"✓ Marketplace repository created at: {repo_dir}")
        return repo_dir

    def _copy_plugins(self, source_dir: Path, dest_dir: Path):
        """Copy plugin directories to marketplace repo."""
        import shutil

        for plugin_path in source_dir.iterdir():
            if plugin_path.is_dir() and (plugin_path / ".claude-plugin").exists():
                dest_plugin = dest_dir / plugin_path.name
                if dest_plugin.exists():
                    shutil.rmtree(dest_plugin)
                shutil.copytree(plugin_path, dest_plugin)

    def _create_root_marketplace_json(self, repo_dir: Path, prd: PRD):
        """Create root marketplace.json."""
        plugins = []

        for plugin_dir in repo_dir.iterdir():
            manifest_path = plugin_dir / ".claude-plugin" / "plugin.json"
            if manifest_path.exists():
                manifest = json.loads(manifest_path.read_text())
                plugins.append({
                    "name": manifest["name"],
                    "displayName": manifest.get("displayName", manifest["name"]),
                    "description": manifest.get("description", ""),
                    "version": manifest.get("version", "1.0.0"),
                    "keywords": manifest.get("keywords", []),
                    "source": f"./{manifest['name']}"
                })

        marketplace = {
            "name": f"Interview Plugins for {prd.user.name}",
            "description": "Personalized plugin marketplace from AI interview",
            "author": {
                "name": prd.user.name,
            },
            "plugins": plugins
        }

        marketplace_file = repo_dir / ".claude-plugin" / "marketplace.json"
        marketplace_file.parent.mkdir(exist_ok=True)
        marketplace_file.write_text(json.dumps(marketplace, indent=2))

    def _create_repo_readme(self, repo_dir: Path, prd: PRD):
        """Create repository README."""
        plugins = [p.name for p in repo_dir.iterdir() if p.is_dir() and p.name[0] != '.']

        readme = f"""# {prd.user.name}'s Claude Code Plugins

Personalized plugin marketplace generated from AI-powered interview.

## Quick Start

Add this marketplace to Claude Code:

```bash
/plugin marketplace add [your-github-username]/[repo-name]
```

Browse and install plugins:

```bash
/plugin install [plugin-name]@[repo-name]
```

## Available Plugins ({len(plugins)})

{chr(10).join(f'### {name}{chr(10)}[View Details](./{name}/README.md){chr(10)}' for name in plugins)}

## About This Marketplace

This marketplace was automatically generated by the Interview Agent system, which:
1. Conducted an intelligent interview about your workflows
2. Discovered your specific AI automation needs
3. Generated personalized plugins to address those needs
4. Packaged everything for easy installation

**Interview Date**: {datetime.now().strftime('%Y-%m-%d')}
**User Profile**: {prd.user.role} in {prd.user.industry or 'General'} industry

## Installation Instructions

See [INSTALL.md](./INSTALL.md) for detailed installation steps.

## License

Individual plugins may have different licenses. Check each plugin's README.
"""
        (repo_dir / "README.md").write_text(readme)

    def _create_repo_claude_md(self, repo_dir: Path, prd: PRD):
        """Create CLAUDE.md for repository context."""
        claude_md = f"""# Interview-Generated Plugin Marketplace

## Purpose
This repository contains Claude Code plugins automatically generated from a user interview.

## User Context
- **Name**: {prd.user.name}
- **Role**: {prd.user.role}
- **Experience**: {prd.user.experience_level}
- **Industry**: {prd.user.industry or 'General'}

## Requirements Addressed
{chr(10).join(f'- {req.name}: {req.description}' for req in prd.requirements.all_requirements[:5])}

## How to Use
Users should install plugins from this marketplace based on their interview recommendations.

Each plugin addresses specific needs discovered during the interview process.

## Maintenance
Plugins can be updated as requirements evolve. Re-run the interview process to generate updated plugins.
"""
        (repo_dir / "CLAUDE.md").write_text(claude_md)

    def _create_install_guide(self, repo_dir: Path, marketplace_name: str):
        """Create detailed installation guide."""
        guide = f"""# Installation Guide

## Method 1: Claude Code UI (Easiest)

1. Open Claude Code
2. Type: `/plugin marketplace add [your-github-username]/{marketplace_name}`
3. Type: `/plugin` to browse available plugins
4. Select and install the plugins you need

## Method 2: Command Line

```bash
# Add marketplace
/plugin marketplace add [your-github-username]/{marketplace_name}

# List available plugins
/plugin list

# Install specific plugin
/plugin install [plugin-name]@{marketplace_name}
```

## Method 3: NPM CLI Tool

```bash
# Install the community CLI tool (one-time)
npm install -g claude-plugins

# Install plugins
npx claude-plugins install @[username]/{marketplace_name}/[plugin-name]
```

## Method 4: Project Configuration

Add to your project's `.claude/settings.json`:

```json
{{
  "plugins": {{
    "[plugin-name]": {{
      "marketplace": "[your-github-username]/{marketplace_name}",
      "version": "1.0.0"
    }}
  }}
}}
```

## Verify Installation

```bash
/plugin list --installed
```

## Troubleshooting

### Marketplace Not Found
- Ensure the repository is public
- Check the repository name matches
- Verify `.claude-plugin/marketplace.json` exists

### Plugin Installation Fails
- Check plugin compatibility with your Claude Code version
- Review plugin's README for specific requirements
- Ensure all dependencies are installed

## Need Help?

Open an issue in this repository or consult the Claude Code documentation.
"""
        (repo_dir / "INSTALL.md").write_text(guide)
